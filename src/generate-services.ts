// rpc-nats-alvamind/src/generate-services.ts
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { glob } from 'glob';
import fs from 'node:fs/promises';
import { Project } from 'ts-morph';
import path from 'node:path';
import chokidar from 'chokidar';
import { debounce } from 'lodash';
import { Stats } from 'fs';

const argv = yargs(hideBin(process.argv))
  .command('generate', 'Generate rpc-services.ts file', (yargs) => {
    yargs
      .option('includes', {
        type: 'string',
        describe: 'Glob patterns for including files',
        demandOption: true,
        array: true,
      })
      .option('excludes', {
        type: 'string',
        describe: 'Glob patterns for excluding files',
        default: [],
        array: true,
      })
      .option('output', {
        type: 'string',
        describe: 'Output file path',
        default: 'src/common/rpc/rpc-services.ts',
      })
      .option('watch', {
        type: 'boolean',
        describe: 'Watch for file changes and regenerate',
        default: false,
      })
      .option('logLevel', {
        type: 'string',
        describe: 'Log level (debug, info, warn, error)',
        default: 'info',
      });
  })
  .parseSync();

export async function generateRpcServices(includes: string[], excludes: string[], outputFile: string) {
  const startTime = Date.now();
  console.info('Starting RPC services generation...');

  let files: string[] = [];
  try {
    files = await includes.reduce<Promise<string[]>>(async (acc, include) => {
      const accumulated = await acc;
      const matchedFiles = await glob(include, { ignore: excludes });
      return [...accumulated, ...matchedFiles];
    }, Promise.resolve([]));

    if (!files.length) {
      const emptyOutput = `// This file is auto-generated by rpc-nats-alvamind
// No files found with provided includes/excludes.

import { RPCClient, ClassTypeProxy } from 'rpc-nats-alvamind';

export class RPCServices {
    constructor(private rpcClient: RPCClient) {}
}`;
      await fs.writeFile(outputFile, emptyOutput, 'utf-8');
      console.warn('No files found with provided includes/excludes.');
      return;
    }
    console.info(`Files Scanned: ${files.length}`);
    console.debug('Matched files:', files);
  } catch (error) {
    console.error('Error scanning files:', error);
    return;
  }

  let classes: { name: string; path: string }[] = [];
  const project = new Project({
    tsConfigFilePath: path.join(process.cwd(), 'tsconfig.json'),
  });

  try {
    project.addSourceFilesAtPaths(files);

    classes = project.getSourceFiles().reduce<{ name: string; path: string }[]>((acc, sourceFile) => {
      const foundClasses = sourceFile
        .getClasses()
        .filter(c => c.getName()?.endsWith('Controller'))
        .map((c) => ({
          name: c.getName()!,
          path: sourceFile.getFilePath(),
        }));
      return [...acc, ...foundClasses];
    }, []);

    if (!classes.length) {
      const emptyOutput = `// This file is auto-generated by rpc-nats-alvamind
// No classes found in provided files.

import { RPCClient, ClassTypeProxy } from 'rpc-nats-alvamind';

export class RPCServices {
    constructor(private rpcClient: RPCClient) {}
}`;
      await fs.writeFile(outputFile, emptyOutput, 'utf-8');
      console.warn('No classes found in provided files.');
      return;
    }
    console.info(`Classes detected: ${classes.length}`);
    console.debug('Detected classes:', classes);
  } catch (error) {
    console.error('Error detecting classes:', error);
    return;
  }

  try {
    const classImports = classes
      .map((c) => {
        const sourceFile = project.getSourceFile(c.path);
        const importPath = path.relative(path.dirname(outputFile), c.path)
          .replace(/\\/g, '/')
          .replace(/\.ts$/, '');
        return `import { ${c.name} } from '${importPath}';`;
      })
      .join('\n');

    console.debug('Generated imports:', classImports);

    const classProperties = classes
      .map((c) => `    ${c.name}: ClassTypeProxy<${c.name}>;`)
      .join('\n');

    const classInits = classes
      .map((c) => `        this.${c.name} = this.rpcClient.createProxy(${c.name});`)
      .join('\n');

    const outputCode = `// This file is auto-generated by rpc-nats-alvamind
import { RPCClient, ClassTypeProxy } from 'rpc-nats-alvamind';
${classImports}

export class RPCServices {
${classProperties}

    constructor(private rpcClient: RPCClient) {
${classInits}
    }
}`;

    await fs.writeFile(outputFile, outputCode, 'utf-8');
    console.info(`Generated ${outputFile} with ${classes.length} services.`);
    console.debug('Generated code:', outputCode);
  } catch (error) {
    console.error('Error writing the output file:', error);
    return;
  }

  const endTime = Date.now();
  const duration = (endTime - startTime) / 1000;
  console.info(`Completed in ${duration.toFixed(2)} seconds.`);
}


if (argv._[0] === 'generate') {
  const { includes, excludes, output, watch, logLevel } = argv;
  console.log('Configuration: ', { includes, excludes, output, watch, logLevel });

  if (logLevel) {
    console.debug('Setting log level to:', logLevel)
    if (typeof logLevel === 'string') {
      const lowerLogLevel = logLevel.toLowerCase();
      if (lowerLogLevel === 'debug') {
        console.debug = console.log;
      } else if (lowerLogLevel === 'info') {
        console.debug = () => { };
      } else if (lowerLogLevel === 'warn') {
        console.debug = () => { };
        console.info = () => { };

      } else if (lowerLogLevel === 'error') {
        console.debug = () => { };
        console.info = () => { };
        console.warn = () => { };
      }
    }
  }

  const generate = async () => {
    await generateRpcServices(includes as string[], excludes as string[], output as string);
  };

  generate();

  if (watch) {
    const watcher = chokidar.watch(includes as string[], {
      ignored: excludes as string[],
      ignoreInitial: true,
    });

    const debouncedGenerate = debounce(generate, 300);

    type EventName = 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir' | 'error' | 'ready' | 'raw' | 'all';

    watcher.on('all', (event: EventName, path: string, stats?: Stats) => {
      console.info(`File changed: ${path}, event: ${event}. Regenerating...`);
      debouncedGenerate();
    });

    console.info('Watching for changes...');
  }
}
