// rpc-nats-alvamind/test/generate.test.ts
import { describe, test, beforeAll, afterAll, expect, beforeEach } from 'bun:test';
import { generateRpcServices } from '../src/generate-services';
import fs from 'node:fs/promises';
import path from 'node:path';

const testDir = path.join(process.cwd(), 'test-temp');
const outputFilePath = path.join(testDir, 'rpc-services.ts');
const rpcDir = path.join(testDir, 'rpc');
const controllersDir = path.join(rpcDir, 'controllers');
const modelsDir = path.join(testDir, 'models');

const createTestFiles = async () => {
  await fs.mkdir(controllersDir, { recursive: true });
  await fs.mkdir(modelsDir, { recursive: true });
  // Controller 1 with complex imports
  await fs.writeFile(path.join(controllersDir, 'user.controller.ts'), `
    import { User } from '../../models/user.model';
    import { Logger } from '../logger';

    export class UserController {
        constructor(private logger: Logger) {}

        async getUser(id: number): Promise<User> {
           this.logger.log('Getting user:'+ id)
            return { id, name: 'Test User' };
        }

        async createUser(user: User): Promise<User> {
             this.logger.log('Creating user:'+ user.name);
            return user;
        }
    }
    `);
  // Controller 2 with different structure
  await fs.writeFile(path.join(controllersDir, 'auth.controller.ts'), `
    export class AuthController {
        async login(credentials: {user:string, pass:string}): Promise<string> {
            if (credentials.user === 'test' && credentials.pass === 'test') return 'token';
            return 'invalid credentials';
        }

        async logout(): Promise<void> {
          return;
        }
    }
    `);
  await fs.writeFile(path.join(modelsDir, 'user.model.ts'), `
    export interface User {
        id: number;
        name: string;
    }
     `);
  // Dummy file
  await fs.writeFile(path.join(testDir, 'dummy.ts'), 'export const dummy = 1;');
  // Non-Controller service file
  await fs.writeFile(path.join(rpcDir, 'logger.ts'), `
    export class Logger {
        log(message: string) {
            console.log('LOGGER:' + message)
        }
    }
    `);

};

const deleteTestFiles = async () => {
  await fs.rm(testDir, { recursive: true, force: true });
};

describe('generateRpcServices - Real Scenarios', () => {
  beforeAll(async () => {
    await createTestFiles();
  });

  afterAll(async () => {
    await deleteTestFiles();
  });

  test('should generate rpc-services.ts correctly with multiple controllers and complex paths', async () => {
    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('// This file is auto-generated by rpc-nats-alvamind');
    expect(outputFileContent).toContain(`import { UserController } from '${path.relative(path.dirname(outputFilePath), path.join(controllersDir, 'user.controller.ts')).replace(/\\/g, '/').replace(/\.ts$/, '')}'`);
    expect(outputFileContent).toContain(`import { AuthController } from '${path.relative(path.dirname(outputFilePath), path.join(controllersDir, 'auth.controller.ts')).replace(/\\/g, '/').replace(/\.ts$/, '')}'`);
    expect(outputFileContent).toContain('    UserController: ClassTypeProxy<UserController>;');
    expect(outputFileContent).toContain('    AuthController: ClassTypeProxy<AuthController>;');
    expect(outputFileContent).toContain('        this.UserController = this.rpcClient.createProxy(UserController);');
    expect(outputFileContent).toContain('        this.AuthController = this.rpcClient.createProxy(AuthController);');
  });


  test('should handle no controller files found', async () => {
    const includes = [`${testDir}/non-existent/**/*.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('No files found with provided includes/excludes.');
  });

  test('should ignore non-controller files', async () => {
    // Change the includes pattern to only match the logger.ts file
    const includes = [`${rpcDir}/logger.ts`]; // Only include non-controller file
    const excludes = [`${controllersDir}/**/*.ts`]; // Explicitly exclude controller files

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('// No classes found in provided files.');
  });


  test('should handle edge case file paths and names', async () => {
    await fs.mkdir(path.join(controllersDir, 'subdir'), { recursive: true });
    await fs.writeFile(path.join(controllersDir, 'subdir', 'some-long-name.controller.ts'), `
            export class SomeLongNameController {
                async someMethod(): Promise<void> {
                  return;
                }
            }
        `);
    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [];
    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain(`import { SomeLongNameController } from '${path.relative(path.dirname(outputFilePath), path.join(controllersDir, 'subdir', 'some-long-name.controller.ts')).replace(/\\/g, '/').replace(/\.ts$/, '')}';`);
    expect(outputFileContent).toContain('SomeLongNameController: ClassTypeProxy<SomeLongNameController>;');
    expect(outputFileContent).toContain('this.SomeLongNameController = this.rpcClient.createProxy(SomeLongNameController);');
  });
});

describe('generateRpcServices - Edge Cases and Error Handling', () => {
  beforeEach(async () => {
    await deleteTestFiles();
    await createTestFiles();
  });

  afterAll(async () => {
    await deleteTestFiles();
  });

  test('should handle multiple includes patterns correctly', async () => {
    // Create both controller directories
    await fs.mkdir(path.join(testDir, 'other-controllers'), { recursive: true });
    await fs.writeFile(
      path.join(testDir, 'other-controllers', 'payment.controller.ts'),
      `
      export class PaymentController {
          async processPayment(): Promise<boolean> {
              return true;
          }
      }
      `
    );

    const includes = [
      `${controllersDir}/**/*.ts`,
      `${testDir}/other-controllers/**/*.ts`
    ];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('PaymentController');
    expect(outputFileContent).toContain('UserController');
    expect(outputFileContent).toContain('AuthController');
  });

  test('should handle excludes patterns correctly', async () => {
    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [`${controllersDir}/**/auth.controller.ts`];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('UserController');
    expect(outputFileContent).not.toContain('AuthController');
  });

  test('should handle files with multiple classes', async () => {
    await fs.writeFile(
      path.join(controllersDir, 'multiple.controller.ts'),
      `
      export class FirstController {
          async method1(): Promise<void> {}
      }

      export class SecondController {
          async method2(): Promise<void> {}
      }

      export class NonControllerClass {
          method3() {}
      }
      `
    );

    const includes = [`${controllersDir}/multiple.controller.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('FirstController');
    expect(outputFileContent).toContain('SecondController');
    expect(outputFileContent).not.toContain('NonControllerClass');
  });

  test('should handle invalid TypeScript syntax gracefully', async () => {
    // First write valid controllers
    await createTestFiles();

    // Then add invalid controller
    await fs.writeFile(
      path.join(controllersDir, 'invalid.controller.ts'),
      `
      export class InvalidController {
          async broken(): Promise<void>
          // Missing implementation and closing brace
      `
    );

    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    // Should still generate valid output for other controllers
    expect(outputFileContent).toContain('UserController');
    expect(outputFileContent).toContain('AuthController');
  });

  test('should handle empty controller classes', async () => {
    await fs.writeFile(
      path.join(controllersDir, 'empty.controller.ts'),
      `
      export class EmptyController {}
      `
    );

    const includes = [`${controllersDir}/empty.controller.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('EmptyController');
  });

  test('should handle output to non-existent directory', async () => {
    const newOutputPath = path.join(testDir, 'new-dir', 'rpc-services.ts');
    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, newOutputPath);
    const outputFileContent = await fs.readFile(newOutputPath, 'utf-8');

    expect(outputFileContent).toContain('UserController');
    expect(outputFileContent).toContain('AuthController');
  });
});
