// rpc-nats-alvamind/test/generate.test.ts
import { describe, test, beforeAll, afterAll, expect } from 'bun:test';
import { generateRpcServices } from '../src/generate-services';
import fs from 'node:fs/promises';
import path from 'node:path';

const testDir = path.join(process.cwd(), 'test-temp');
const outputFilePath = path.join(testDir, 'rpc-services.ts');
const rpcDir = path.join(testDir, 'rpc');
const controllersDir = path.join(rpcDir, 'controllers');
const modelsDir = path.join(testDir, 'models');

const createTestFiles = async () => {
  await fs.mkdir(controllersDir, { recursive: true });
  await fs.mkdir(modelsDir, { recursive: true });
  // Controller 1 with complex imports
  await fs.writeFile(path.join(controllersDir, 'user.controller.ts'), `
    import { User } from '../../models/user.model';
    import { Logger } from '../logger';

    export class UserController {
        constructor(private logger: Logger) {}

        async getUser(id: number): Promise<User> {
           this.logger.log('Getting user:'+ id)
            return { id, name: 'Test User' };
        }

        async createUser(user: User): Promise<User> {
             this.logger.log('Creating user:'+ user.name);
            return user;
        }
    }
    `);
  // Controller 2 with different structure
  await fs.writeFile(path.join(controllersDir, 'auth.controller.ts'), `
    export class AuthController {
        async login(credentials: {user:string, pass:string}): Promise<string> {
            if (credentials.user === 'test' && credentials.pass === 'test') return 'token';
            return 'invalid credentials';
        }

        async logout(): Promise<void> {
          return;
        }
    }
    `);
  await fs.writeFile(path.join(modelsDir, 'user.model.ts'), `
    export interface User {
        id: number;
        name: string;
    }
     `);
  // Dummy file
  await fs.writeFile(path.join(testDir, 'dummy.ts'), 'export const dummy = 1;');
  // Non-Controller service file
  await fs.writeFile(path.join(rpcDir, 'logger.ts'), `
    export class Logger {
        log(message: string) {
            console.log('LOGGER:' + message)
        }
    }
    `);

};

const deleteTestFiles = async () => {
  await fs.rm(testDir, { recursive: true, force: true });
};

describe('generateRpcServices - Real Scenarios', () => {
  beforeAll(async () => {
    await createTestFiles();
  });

  afterAll(async () => {
    await deleteTestFiles();
  });

  test('should generate rpc-services.ts correctly with multiple controllers and complex paths', async () => {
    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('// This file is auto-generated by rpc-nats-alvamind');
    expect(outputFileContent).toContain(`import { UserController } from '${path.relative(path.dirname(outputFilePath), path.join(controllersDir, 'user.controller.ts')).replace(/\\/g, '/').replace(/\.ts$/, '')}'`);
    expect(outputFileContent).toContain(`import { AuthController } from '${path.relative(path.dirname(outputFilePath), path.join(controllersDir, 'auth.controller.ts')).replace(/\\/g, '/').replace(/\.ts$/, '')}'`);
    expect(outputFileContent).toContain('    UserController: ClassTypeProxy<UserController>;');
    expect(outputFileContent).toContain('    AuthController: ClassTypeProxy<AuthController>;');
    expect(outputFileContent).toContain('        this.UserController = this.rpcClient.createProxy(UserController);');
    expect(outputFileContent).toContain('        this.AuthController = this.rpcClient.createProxy(AuthController);');
  });


  test('should handle no controller files found', async () => {
    const includes = [`${testDir}/non-existent/**/*.ts`];
    const excludes = [];

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('No files found with provided includes/excludes.');
  });

  test('should ignore non-controller files', async () => {
    // Change the includes pattern to only match the logger.ts file
    const includes = [`${rpcDir}/logger.ts`]; // Only include non-controller file
    const excludes = [`${controllersDir}/**/*.ts`]; // Explicitly exclude controller files

    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain('// No classes found in provided files.');
  });


  test('should handle edge case file paths and names', async () => {
    await fs.mkdir(path.join(controllersDir, 'subdir'), { recursive: true });
    await fs.writeFile(path.join(controllersDir, 'subdir', 'some-long-name.controller.ts'), `
            export class SomeLongNameController {
                async someMethod(): Promise<void> {
                  return;
                }
            }
        `);
    const includes = [`${controllersDir}/**/*.ts`];
    const excludes = [];
    await generateRpcServices(includes, excludes, outputFilePath);
    const outputFileContent = await fs.readFile(outputFilePath, 'utf-8');

    expect(outputFileContent).toContain(`import { SomeLongNameController } from '${path.relative(path.dirname(outputFilePath), path.join(controllersDir, 'subdir', 'some-long-name.controller.ts')).replace(/\\/g, '/').replace(/\.ts$/, '')}';`);
    expect(outputFileContent).toContain('SomeLongNameController: ClassTypeProxy<SomeLongNameController>;');
    expect(outputFileContent).toContain('this.SomeLongNameController = this.rpcClient.createProxy(SomeLongNameController);');
  });
});
