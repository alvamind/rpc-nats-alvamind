function formatDependency(params, idx) {
  if (params === null) {
    return `at position #${idx}`;
  }
  const argName = params.split(",")[idx].trim();
  return `"${argName}" at position #${idx}`;
}
function composeErrorMessage(msg, e, indent = "    ") {
  return [msg, ...e.message.split("\n").map((l) => indent + l)].join("\n");
}
function formatErrorCtor(ctor, paramIdx, error) {
  const [, params = null] = ctor.toString().match(/constructor\(([\w, ]+)\)/) || [];
  const dep = formatDependency(params, paramIdx);
  return composeErrorMessage(
    `Cannot inject the dependency ${dep} of "${ctor.name}" constructor. Reason:`,
    error
  );
}

class RegistryBase {
  constructor() {
    this._registryMap = /* @__PURE__ */ new Map();
  }
  tokens() {
    return Array.from(this._registryMap.keys());
  }
  entries() {
    return this._registryMap.entries();
  }
  getAll(key) {
    this.ensure(key);
    return this._registryMap.get(key);
  }
  get(key) {
    this.ensure(key);
    const value = this._registryMap.get(key);
    return value[value.length - 1] || null;
  }
  set(key, value) {
    this.ensure(key);
    this._registryMap.get(key).push(value);
  }
  setAll(key, value) {
    this._registryMap.set(key, value);
  }
  has(key) {
    this.ensure(key);
    return this._registryMap.get(key).length > 0;
  }
  clear() {
    this._registryMap.clear();
  }
  delete(key) {
    this._registryMap.delete(key);
  }
  ensure(key) {
    if (!this._registryMap.has(key)) {
      this._registryMap.set(key, []);
    }
  }
}

class PostRegistrationInterceptors extends RegistryBase {
}
class PreResolutionInterceptors extends RegistryBase {
}
class PostResolutionInterceptors extends RegistryBase {
}
class Interceptors {
  constructor() {
    this.postRegistration = new PostRegistrationInterceptors();
    this.preResolution = new PreResolutionInterceptors();
    this.postResolution = new PostResolutionInterceptors();
  }
}

class DelayedConstructor {
  constructor(wrap) {
    this.wrap = wrap;
    this.reflectMethods = [
      "get",
      "getPrototypeOf",
      "setPrototypeOf",
      "getOwnPropertyDescriptor",
      "defineProperty",
      "has",
      "set",
      "deleteProperty",
      "apply",
      "construct",
      "ownKeys"
    ];
  }
  createProxy(createObject) {
    const target = {};
    let init = false;
    let value;
    const delayedObject = () => {
      if (!init) {
        value = createObject(this.wrap());
        init = true;
      }
      return value;
    };
    return new Proxy(target, this.createHandler(delayedObject));
  }
  createHandler(delayedObject) {
    const handler = {};
    const install = (name) => {
      handler[name] = (...args) => {
        args[0] = delayedObject();
        const method = Reflect[name];
        return method(...args);
      };
    };
    this.reflectMethods.forEach(install);
    return handler;
  }
}
function delay(wrappedConstructor) {
  if (typeof wrappedConstructor === "undefined") {
    throw new TypeError(
      "Attempt to `delay` undefined. Constructor must be wrapped in a callback"
    );
  }
  return new DelayedConstructor(wrappedConstructor);
}

function isClassProvider(provider) {
  return Boolean(provider.useClass);
}

function isFactoryProvider(provider) {
  return Boolean(provider.useFactory);
}

function isNormalToken(token) {
  return typeof token === "string" || typeof token === "symbol";
}
function isTokenDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
}
function isTransformDescriptor(descriptor) {
  return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
}
function isConstructorToken(token) {
  return typeof token === "function" || token instanceof DelayedConstructor;
}

function isTokenProvider(provider) {
  return Boolean(provider.useToken);
}

function isValueProvider(provider) {
  return Object.prototype.hasOwnProperty.call(provider, "useValue");
}

function isProvider(provider) {
  return isClassProvider(provider) || isValueProvider(provider) || isTokenProvider(provider) || isFactoryProvider(provider);
}

const INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
const PARAM_INFOS_METADATA_KEY = "paramInfos";
function getParamInfo(target) {
  const params = Reflect.getMetadata("design:paramtypes", target) || [];
  const injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
  Object.keys(injectionTokens).forEach((key) => {
    params[Number(key)] = injectionTokens[key];
  });
  return params;
}
function defineInjectionTokenMetadata(data, transform) {
  return function(target, _propertyKey, parameterIndex) {
    const descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    descriptors[parameterIndex] = transform ? {
      token: data,
      transform: transform.transformToken,
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      transformArgs: transform.args ?? []
    } : data;
    Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
  };
}

class Registry extends RegistryBase {
}

class ResolutionContext {
  constructor() {
    this.scopedResolutions = /* @__PURE__ */ new Map();
  }
}

function isDisposable(value) {
  if (typeof value !== "object" || value === null) return false;
  if (!("dispose" in value)) return false;
  if (typeof value.dispose !== "function") return false;
  const disposeFn = value.dispose;
  if (disposeFn.length > 0) {
    return false;
  }
  return true;
}

var Lifecycle = /* @__PURE__ */ ((Lifecycle2) => {
  Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
  Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
  Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
  Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
  return Lifecycle2;
})(Lifecycle || {});

class InternalDependencyContainer {
  constructor(parent) {
    this.parent = parent;
    this._registry = new Registry();
    this.interceptors = new Interceptors();
    this.disposed = false;
    this.disposables = /* @__PURE__ */ new Set();
  }
  register(token, providerOrConstructor, options = { lifecycle: Lifecycle.Transient }) {
    this.ensureNotDisposed();
    let provider;
    if (!isProvider(providerOrConstructor)) {
      provider = { useClass: providerOrConstructor };
    } else {
      provider = providerOrConstructor;
    }
    if (isTokenProvider(provider)) {
      const path = [token];
      let tokenProvider = provider;
      while (tokenProvider != null) {
        const currentToken = tokenProvider.useToken;
        if (path.includes(currentToken)) {
          throw new Error(
            `Token registration cycle detected! ${[...path, currentToken].join(
              " -> "
            )}`
          );
        }
        path.push(currentToken);
        const registration = this._registry.get(currentToken);
        if (registration && isTokenProvider(registration.provider)) {
          tokenProvider = registration.provider;
        } else {
          tokenProvider = null;
        }
      }
    }
    if ((options.lifecycle === Lifecycle.Singleton || options.lifecycle === Lifecycle.ContainerScoped || options.lifecycle === Lifecycle.ResolutionScoped) && (isValueProvider(provider) || isFactoryProvider(provider))) {
      throw new Error(
        `Cannot use lifecycle "${Lifecycle[options.lifecycle]}" with ValueProviders or FactoryProviders`
      );
    }
    this._registry.set(token, { provider, options });
    this.executePostRegistrationInterceptor(token);
    return this;
  }
  registerType(from, to) {
    this.ensureNotDisposed();
    if (isNormalToken(to)) {
      return this.register(from, {
        useToken: to
      });
    }
    return this.register(from, {
      useClass: to
    });
  }
  registerInstance(token, instance2) {
    this.ensureNotDisposed();
    return this.register(token, {
      useValue: instance2
    });
  }
  registerSingleton(from, to) {
    this.ensureNotDisposed();
    if (isNormalToken(from)) {
      if (isNormalToken(to)) {
        return this.register(
          from,
          {
            useToken: to
          },
          { lifecycle: Lifecycle.Singleton }
        );
      }
      if (to) {
        return this.register(
          from,
          {
            useClass: to
          },
          { lifecycle: Lifecycle.Singleton }
        );
      }
      throw new Error(
        'Cannot register a type name as a singleton without a "to" token'
      );
    }
    let useClass = from;
    if (to && !isNormalToken(to)) {
      useClass = to;
    }
    return this.register(
      from,
      {
        useClass
      },
      { lifecycle: Lifecycle.Singleton }
    );
  }
  resolve(token, context = new ResolutionContext()) {
    this.ensureNotDisposed();
    const registration = this.getRegistration(token);
    if (!registration && isNormalToken(token)) {
      throw new Error(
        `Attempted to resolve unregistered dependency token: "${token.toString()}"`
      );
    }
    this.executePreResolutionInterceptor(token, "Single");
    if (registration) {
      const result = this.resolveRegistration(registration, context);
      this.executePostResolutionInterceptor(token, result, "Single");
      return result;
    }
    if (isConstructorToken(token)) {
      const result = this.construct(token, context);
      this.executePostResolutionInterceptor(token, result, "Single");
      return result;
    }
    throw new Error(
      "Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function."
    );
  }
  executePostRegistrationInterceptor(token) {
    if (this.interceptors.postRegistration.has(token)) {
      const remainingInterceptors = [];
      for (const interceptor of this.interceptors.postRegistration.getAll(token)) {
        if (interceptor.options.frequency !== "Once") {
          remainingInterceptors.push(interceptor);
        }
        interceptor.callback(token);
      }
      this.interceptors.postRegistration.setAll(token, remainingInterceptors);
    }
    if (this.interceptors.postAnyRegistration) {
      this.interceptors.postAnyRegistration(token);
    }
  }
  executePreResolutionInterceptor(token, resolutionType) {
    if (this.interceptors.preResolution.has(token)) {
      const remainingInterceptors = [];
      for (const interceptor of this.interceptors.preResolution.getAll(token)) {
        if (interceptor.options.frequency !== "Once") {
          remainingInterceptors.push(interceptor);
        }
        interceptor.callback(token, resolutionType);
      }
      this.interceptors.preResolution.setAll(token, remainingInterceptors);
    }
    if (this.interceptors.preAnyResolution) {
      this.interceptors.preAnyResolution(token, resolutionType);
    }
  }
  executePostResolutionInterceptor(token, result, resolutionType) {
    if (this.interceptors.postResolution.has(token)) {
      const remainingInterceptors = [];
      for (const interceptor of this.interceptors.postResolution.getAll(
        token
      )) {
        if (interceptor.options.frequency !== "Once") {
          remainingInterceptors.push(interceptor);
        }
        interceptor.callback(token, result, resolutionType);
      }
      this.interceptors.postResolution.setAll(token, remainingInterceptors);
    }
    if (this.interceptors.postAnyResolution) {
      this.interceptors.postAnyResolution(token, result, resolutionType);
    }
  }
  resolveRegistration(registration, context) {
    this.ensureNotDisposed();
    if (registration.options.lifecycle === Lifecycle.ResolutionScoped && context.scopedResolutions.has(registration)) {
      return context.scopedResolutions.get(registration);
    }
    const isSingleton = registration.options.lifecycle === Lifecycle.Singleton;
    const isContainerScoped = registration.options.lifecycle === Lifecycle.ContainerScoped;
    const returnInstance = isSingleton || isContainerScoped;
    let newResolution = true;
    let resolved;
    if (isValueProvider(registration.provider)) {
      resolved = registration.provider.useValue;
    } else if (isTokenProvider(registration.provider)) {
      newResolution = returnInstance;
      resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(
        registration.provider.useToken,
        context
      )) : this.resolve(registration.provider.useToken, context);
    } else if (isClassProvider(registration.provider)) {
      newResolution = returnInstance;
      resolved = returnInstance ? registration.instance || (registration.instance = this.construct(
        registration.provider.useClass,
        context
      )) : this.construct(registration.provider.useClass, context);
    } else if (isFactoryProvider(registration.provider)) {
      resolved = registration.provider.useFactory(this);
    } else {
      newResolution = false;
      resolved = this.construct(registration.provider, context);
    }
    if (registration.options.lifecycle === Lifecycle.ResolutionScoped) {
      context.scopedResolutions.set(registration, resolved);
    }
    if (newResolution && isDisposable(resolved)) {
      this.disposables.add(resolved);
    }
    return resolved;
  }
  resolveAll(token, context = new ResolutionContext()) {
    this.ensureNotDisposed();
    const registrations = this.getAllRegistrations(token);
    if (!registrations && isNormalToken(token)) {
      throw new Error(
        `Attempted to resolve unregistered dependency token: "${token.toString()}"`
      );
    }
    this.executePreResolutionInterceptor(token, "All");
    if (registrations) {
      const result2 = registrations.map(
        (item) => this.resolveRegistration(item, context)
      );
      this.executePostResolutionInterceptor(token, result2, "All");
      return result2;
    }
    const result = [this.construct(token, context)];
    this.executePostResolutionInterceptor(token, result, "All");
    return result;
  }
  registeredTokens() {
    return this._registry.tokens();
  }
  isRegistered(token, recursive = false) {
    this.ensureNotDisposed();
    return this._registry.has(token) || ((recursive && this.parent?.isRegistered(token, true)) ?? false);
  }
  reset() {
    this.ensureNotDisposed();
    this._registry.clear();
    this.interceptors.preResolution.clear();
    this.interceptors.postResolution.clear();
  }
  unregisterAll() {
    this._registry.clear();
    this.interceptors.preResolution.clear();
    this.interceptors.postResolution.clear();
  }
  unregister(token) {
    const registration = this.getRegistration(token);
    if (!registration) {
      throw new Error(
        `Attempted to delete unregistered dependency token: "${token.toString()}"`
      );
    }
    this._registry.delete(token);
    this.interceptors.preResolution.delete(token);
    this.interceptors.postResolution.delete(token);
  }
  clearInstances() {
    this.ensureNotDisposed();
    for (const [token, registrations] of this._registry.entries()) {
      this._registry.setAll(
        token,
        registrations.filter((registration) => !isValueProvider(registration.provider)).map((registration) => {
          registration.instance = void 0;
          return registration;
        })
      );
    }
  }
  createChildContainer() {
    this.ensureNotDisposed();
    const childContainer = new InternalDependencyContainer(this);
    for (const [token, registrations] of this._registry.entries()) {
      if (registrations.some(
        ({ options }) => options.lifecycle === Lifecycle.ContainerScoped
      )) {
        childContainer._registry.setAll(
          token,
          registrations.map((registration) => {
            if (registration.options.lifecycle === Lifecycle.ContainerScoped) {
              return {
                provider: registration.provider,
                options: registration.options
              };
            }
            return registration;
          })
        );
      }
    }
    return childContainer;
  }
  afterRegistration(token, callback, options = { frequency: "Always" }) {
    this.interceptors.postRegistration.set(token, {
      callback,
      options
    });
  }
  afterAnyRegistration(callback) {
    this.interceptors.postAnyRegistration = callback;
  }
  beforeResolution(token, callback, options = { frequency: "Always" }) {
    this.interceptors.preResolution.set(token, {
      callback,
      options
    });
  }
  beforeAnyResolution(callback) {
    this.interceptors.preAnyResolution = callback;
  }
  afterResolution(token, callback, options = { frequency: "Always" }) {
    this.interceptors.postResolution.set(token, {
      callback,
      options
    });
  }
  afterAnyResolution(callback) {
    this.interceptors.postAnyResolution = callback;
  }
  async dispose() {
    this.disposed = true;
    const promises = [];
    this.disposables.forEach((disposable) => {
      const maybePromise = disposable.dispose();
      if (maybePromise) {
        promises.push(maybePromise);
      }
    });
    await Promise.all(promises);
  }
  getRegistration(token) {
    if (this.isRegistered(token)) {
      return this._registry.get(token);
    }
    if (this.parent) {
      return this.parent.getRegistration(token);
    }
    return null;
  }
  getAllRegistrations(token) {
    if (this.isRegistered(token)) {
      return this._registry.getAll(token);
    }
    if (this.parent) {
      return this.parent.getAllRegistrations(token);
    }
    return null;
  }
  construct(ctor, context) {
    if (ctor instanceof DelayedConstructor) {
      return ctor.createProxy(
        (target) => this.resolve(target, context)
      );
    }
    const instance2 = (() => {
      const paramInfo = Reflect.getMetadata(PARAM_INFOS_METADATA_KEY, ctor);
      if (!paramInfo || paramInfo.length === 0) {
        if (ctor.length === 0) {
          return new ctor();
        }
        throw new Error(`TypeInfo not known for "${ctor.name}"`);
      }
      const params = paramInfo.map(this.resolveParams(context, ctor));
      return new ctor(...params);
    })();
    if (isDisposable(instance2)) {
      this.disposables.add(instance2);
    }
    return instance2;
  }
  resolveParams(context, ctor) {
    return (param, idx) => {
      try {
        if (isTokenDescriptor(param)) {
          if (isTransformDescriptor(param)) {
            return param.multiple ? this.resolve(param.transform).transform(
              this.resolveAll(param.token),
              ...param.transformArgs
            ) : this.resolve(param.transform).transform(
              this.resolve(param.token, context),
              ...param.transformArgs
            );
          }
          return param.multiple ? this.resolveAll(param.token) : this.resolve(param.token, context);
        }
        if (isTransformDescriptor(param)) {
          return this.resolve(param.transform, context).transform(
            this.resolve(param.token, context),
            ...param.transformArgs
          );
        }
        return this.resolve(param, context);
      } catch (error) {
        throw new Error(formatErrorCtor(ctor, idx, error));
      }
    };
  }
  ensureNotDisposed() {
    if (this.disposed) {
      throw new Error(
        "This container has been disposed, you cannot interact with a disposed container"
      );
    }
  }
}
const instance = new InternalDependencyContainer();

function autoInjectable() {
  return function(target) {
    const paramInfo = getParamInfo(target);
    return class extends target {
      constructor(...args) {
        super(
          ...args.concat(
            paramInfo.slice(args.length).map((type, index) => {
              try {
                if (isTokenDescriptor(type)) {
                  if (isTransformDescriptor(type)) {
                    return type.multiple ? instance.resolve(type.transform).transform(
                      instance.resolveAll(type.token),
                      ...type.transformArgs
                    ) : instance.resolve(type.transform).transform(
                      instance.resolve(type.token),
                      ...type.transformArgs
                    );
                  }
                  return type.multiple ? instance.resolveAll(type.token) : instance.resolve(type.token);
                }
                if (isTransformDescriptor(type)) {
                  return instance.resolve(type.transform).transform(
                    instance.resolve(type.token),
                    ...type.transformArgs
                  );
                }
                return instance.resolve(type);
              } catch (error) {
                const argIndex = index + args.length;
                throw new Error(
                  formatErrorCtor(target, argIndex, error)
                );
              }
            })
          )
        );
      }
    };
  };
}

function inject(token) {
  return defineInjectionTokenMetadata(token);
}

function injectAll(token) {
  const data = { token, multiple: true };
  return defineInjectionTokenMetadata(data);
}

function injectAllWithTransform(token, transformer, ...args) {
  const data = {
    token,
    multiple: true,
    transform: transformer,
    transformArgs: args
  };
  return defineInjectionTokenMetadata(data);
}

function injectWithTransform(token, transformer, ...args) {
  return defineInjectionTokenMetadata(token, {
    transformToken: transformer,
    args
  });
}

function injectable() {
  return function(target) {
    const paramInfo = getParamInfo(target);
    Reflect.defineMetadata(PARAM_INFOS_METADATA_KEY, paramInfo, target);
  };
}

function registry(registrations = []) {
  return function(target) {
    registrations.forEach(
      ({ token, options, ...provider }) => instance.register(token, provider, options)
    );
    return target;
  };
}

function scoped(lifecycle, token) {
  return function(target) {
    injectable()(target);
    instance.register(token || target, target, {
      lifecycle
    });
  };
}

function singleton() {
  return function(target) {
    injectable()(target);
    instance.registerSingleton(target);
  };
}

function instanceCachingFactory(factoryFunc) {
  let instance;
  return (dependencyContainer) => {
    if (instance == null) {
      instance = factoryFunc(dependencyContainer);
    }
    return instance;
  };
}

function instancePerContainerCachingFactory(factoryFunc) {
  const cache = /* @__PURE__ */ new WeakMap();
  return (dependencyContainer) => {
    let instance = cache.get(dependencyContainer);
    if (instance == null) {
      instance = factoryFunc(dependencyContainer);
      cache.set(dependencyContainer, instance);
    }
    return instance;
  };
}

function predicateAwareClassFactory(predicate, trueConstructor, falseConstructor, useCaching = true) {
  let instance;
  let previousPredicate;
  return (dependencyContainer) => {
    const currentPredicate = predicate(dependencyContainer);
    if (!useCaching || previousPredicate !== currentPredicate) {
      if (previousPredicate = currentPredicate) {
        instance = dependencyContainer.resolve(trueConstructor);
      } else {
        instance = dependencyContainer.resolve(falseConstructor);
      }
    }
    return instance;
  };
}

if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
  throw new Error(
    `tsyringe-neo requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`
  );
}

export { Lifecycle, autoInjectable, instance as container, delay, inject, injectAll, injectAllWithTransform, injectWithTransform, injectable, instanceCachingFactory, instancePerContainerCachingFactory, isClassProvider, isFactoryProvider, isNormalToken, isTokenProvider, isValueProvider, predicateAwareClassFactory, registry, scoped, singleton };
