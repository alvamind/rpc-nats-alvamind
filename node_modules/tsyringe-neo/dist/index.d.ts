/** Constructor type */
type ConstructorType<T> = {
    new (...args: any[]): T;
};

/**
 * Class decorator factory that replaces the decorated class' constructor with
 * a parameterless constructor that has dependencies auto-resolved
 *
 * Note: Resolution is performed using the global container
 *
 * @return {Function} The class decorator
 */
declare function autoInjectable(): (target: ConstructorType<any>) => any;

declare class DelayedConstructor<T> {
    private wrap;
    private reflectMethods;
    constructor(wrap: () => ConstructorType<T>);
    createProxy(createObject: (ctor: ConstructorType<T>) => T): T;
    private createHandler;
}
declare function delay<T>(wrappedConstructor: () => ConstructorType<T>): DelayedConstructor<T>;

type Transform<TIn, TOut> = {
    transform: (incoming: TIn, ...args: any[]) => TOut;
};

type InjectionToken<T = any> = ConstructorType<T> | string | symbol | DelayedConstructor<T>;
declare function isNormalToken(token?: InjectionToken<any>): token is string | symbol;

/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata
 *
 * @return {Function} The parameter decorator
 */
declare function inject(token: InjectionToken<any>): (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) => any;

/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata
 *
 * @return {Function} The parameter decorator
 */
declare function injectAll(token: InjectionToken<any>): (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) => any;

/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata
 *
 * @return {Function} The parameter decorator
 */
declare function injectAllWithTransform(token: InjectionToken<any>, transformer: InjectionToken<Transform<[any], any>>, ...args: any[]): (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) => any;

type TokenProvider<T> = {
    useToken: InjectionToken<T>;
};
declare function isTokenProvider<T>(provider: Provider<T>): provider is TokenProvider<any>;

type ValueProvider<T> = {
    useValue: T;
};
declare function isValueProvider<T>(provider: Provider<T>): provider is ValueProvider<T>;

type Disposable = {
    dispose(): Promise<void> | void;
};

type Frequency = 'Always' | 'Once';

type InterceptorOptions = {
    frequency: Frequency;
};

declare enum Lifecycle {
    Transient = 0,
    Singleton = 1,
    ResolutionScoped = 2,
    ContainerScoped = 3
}

type RegistrationOptions = {
    /**
     * Customize the lifecycle of the registration
     * See https://github.com/risen228/tsyringe-neo#available-scopes for more information
     */
    lifecycle: Lifecycle;
};

type ResolutionType = 'Single' | 'All';
type PostRegistrationInterceptorCallback<T = any> = {
    /**
     * @param token The InjectionToken that was intercepted
     */
    (token: InjectionToken<T>): void;
};
type PreResolutionInterceptorCallback<T = any> = {
    /**
     * @param token The InjectionToken that was intercepted
     * @param resolutionType The type of resolve that was called (i.e. All or Single)
     */
    (token: InjectionToken<T>, resolutionType: ResolutionType): void;
};
type PostResolutionInterceptorCallback<T = any> = {
    /**
     * @param token The InjectionToken that was intercepted
     * @param result The object that was resolved from the container
     * @param resolutionType The type of resolve that was called (i.e. All or Single)
     */
    (token: InjectionToken<T>, result: T | T[], resolutionType: ResolutionType): void;
};
type DependencyContainer = {
    register<T>(token: InjectionToken<T>, provider: ValueProvider<T>): DependencyContainer;
    register<T>(token: InjectionToken<T>, provider: FactoryProvider<T>): DependencyContainer;
    register<T>(token: InjectionToken<T>, provider: TokenProvider<T>, options?: RegistrationOptions): DependencyContainer;
    register<T>(token: InjectionToken<T>, provider: ClassProvider<T>, options?: RegistrationOptions): DependencyContainer;
    register<T>(token: InjectionToken<T>, provider: ConstructorType<T>, options?: RegistrationOptions): DependencyContainer;
    registerSingleton<T>(from: InjectionToken<T>, to: InjectionToken<T>): DependencyContainer;
    registerSingleton<T>(token: ConstructorType<T>): DependencyContainer;
    registerType<T>(from: InjectionToken<T>, to: InjectionToken<T>): DependencyContainer;
    registerInstance<T>(token: InjectionToken<T>, instance: T): DependencyContainer;
    /**
     * Resolve a token into an instance
     *
     * @param token The dependency token
     * @return An instance of the dependency
     */
    resolve<T>(token: InjectionToken<T>): T;
    resolveAll<T>(token: InjectionToken<T>): T[];
    /**
     * Gets all registered tokens
     */
    registeredTokens(): InjectionToken<any>[];
    /**
     * Check if the given dependency is registered
     *
     * @param token The token to check
     * @param recursive Should parent containers be checked?
     * @return Whether or not the token is registered
     */
    isRegistered<T>(token: InjectionToken<T>, recursive?: boolean): boolean;
    /**
     * Clears all registered tokens
     */
    reset(): void;
    unregisterAll(): void;
    unregister<T>(token: InjectionToken<T>): void;
    clearInstances(): void;
    createChildContainer(): DependencyContainer;
    /**
     * Registers a callback that is called when a specific injection token is registered
     * @param token The token to intercept
     * @param callback The callback that is called after the token is registered
     * @param options Options for under what circumstances the callback will be called
     */
    afterRegistration<T>(token: InjectionToken<T>, callback: PostRegistrationInterceptorCallback<T>, options?: InterceptorOptions): void;
    /**
     * Registers a callback that is called after any registration
     * @param callback The callback that is called after any registration
     */
    afterAnyRegistration(callback: PostRegistrationInterceptorCallback<any>): void;
    /**
     * Registers a callback that is called when a specific injection token is resolved
     * @param token The token to intercept
     * @param callback The callback that is called before the token is resolved
     * @param options Options for under what circumstances the callback will be called
     */
    beforeResolution<T>(token: InjectionToken<T>, callback: PreResolutionInterceptorCallback<T>, options?: InterceptorOptions): void;
    /**
     * Registers a callback that is called before any resolution
     * @param callback The callback that is called before any resolution
     */
    beforeAnyResolution(callback: PreResolutionInterceptorCallback<any>): void;
    /**
     * Registers a callback that is called after a successful resolution of the token
     * @param token The token to intercept
     * @param callback The callback that is called after the token is resolved
     * @param options Options for under what circumstances the callback will be called
     */
    afterResolution<T>(token: InjectionToken<T>, callback: PostResolutionInterceptorCallback<T>, options?: InterceptorOptions): void;
    /**
     * Registers a callback that is called after any successful resolution
     * @param callback The callback that is called after any resolution
     * @param options
     */
    afterAnyResolution(callback: PostResolutionInterceptorCallback<any>): void;
    /**
     * Calls `.dispose()` on all disposable instances created by the container.
     * After calling this, the container may no longer be used.
     */
    dispose(): Promise<void> | void;
} & Disposable;

/**
 * Provide a dependency using a factory.
 * Unlike the other providers, this does not support instance caching. If
 * you need instance caching, your factory method must implement it.
 */
type FactoryProvider<T> = {
    useFactory: (dependencyContainer: DependencyContainer) => T;
};
declare function isFactoryProvider<T>(provider: Provider<T>): provider is FactoryProvider<any>;

type Provider<T = any> = ClassProvider<T> | ValueProvider<T> | TokenProvider<T> | FactoryProvider<T>;

type ClassProvider<T> = {
    useClass: ConstructorType<T> | DelayedConstructor<T>;
};
declare function isClassProvider<T>(provider: Provider<T>): provider is ClassProvider<any>;

/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata with a transform token
 * @param token The token of the object to be resolved
 * @param transformer The token of the transform object
 * @param args Arguments to be passed to the transform method on the transformer
 * @returns The parameter decorator
 */
declare function injectWithTransform(token: InjectionToken<any>, transformer: InjectionToken<Transform<any, any>>, ...args: any[]): (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) => any;

/**
 * Class decorator factory that allows the class' dependencies to be injected
 * at runtime.
 *
 * @return {Function} The class decorator
 */
declare function injectable<T>(): (target: ConstructorType<T>) => void;

/**
 * Class decorator factory that allows constructor dependencies to be registered at runtime.
 *
 * @return {Function} The class decorator
 */
declare function registry(registrations?: ({
    token: InjectionToken;
    options?: RegistrationOptions;
} & Provider<any>)[]): (target: any) => any;

/**
 * Class decorator factory that registers the class as a scoped dependency within
 * the global container.
 *
 * @return The class decorator
 */
declare function scoped<T>(lifecycle: Lifecycle.ContainerScoped | Lifecycle.ResolutionScoped, token?: InjectionToken<T>): (target: ConstructorType<T>) => void;

/**
 * Class decorator factory that registers the class as a singleton within
 * the global container.
 *
 * @return {Function} The class decorator
 */
declare function singleton<T>(): (target: ConstructorType<T>) => void;

declare const instance: DependencyContainer;

type FactoryFunction<T> = (dependencyContainer: DependencyContainer) => T;

declare function instanceCachingFactory<T>(factoryFunc: FactoryFunction<T>): FactoryFunction<T>;

declare function instancePerContainerCachingFactory<T>(factoryFunc: FactoryFunction<T>): FactoryFunction<T>;

declare function predicateAwareClassFactory<T>(predicate: (dependencyContainer: DependencyContainer) => boolean, trueConstructor: ConstructorType<T>, falseConstructor: ConstructorType<T>, useCaching?: boolean): FactoryFunction<T>;

export { type ClassProvider, type DependencyContainer, type Disposable, type FactoryFunction, type FactoryProvider, type Frequency, type InjectionToken, Lifecycle, type Provider, type RegistrationOptions, type TokenProvider, type ValueProvider, autoInjectable, instance as container, delay, inject, injectAll, injectAllWithTransform, injectWithTransform, injectable, instanceCachingFactory, instancePerContainerCachingFactory, isClassProvider, isFactoryProvider, isNormalToken, isTokenProvider, isValueProvider, predicateAwareClassFactory, registry, scoped, singleton };
