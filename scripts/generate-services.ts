#!/usr/bin/env node

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import glob from 'glob';
import fs from 'node:fs/promises';
import { Project, SourceFile } from 'ts-morph';
import path from 'node:path';
import chokidar from 'chokidar';
import { debounce } from 'lodash';
import { Logger } from '../src/core/utils/logger';

const argv = yargs(hideBin(process.argv))
  .command('generate', 'Generate rpc-services.ts file', (yargs) => {
    yargs
      .option('includes', {
        type: 'string',
        describe: 'Glob patterns for including files',
        demandOption: true,
        array: true
      })
      .option('excludes', {
        type: 'string',
        describe: 'Glob patterns for excluding files',
        default: [],
        array: true
      })
      .option('output', {
        type: 'string',
        describe: 'Output file path',
        default: 'src/common/rpc/rpc-services.ts'
      })
      .option('watch', {
        type: 'boolean',
        describe: 'Watch for file changes and regenerate',
        default: false,
      })
      .option('logLevel', {
        type: 'string',
        describe: 'Log level (debug, info, warn, error)',
        default: 'info'
      });
  })
  .parseSync();

// Set log level from command line argument
Logger.setLogLevel(argv.logLevel as any);

async function generateRpcServices(includes: string[], excludes: string[], outputFile: string) {
  const startTime = Date.now();
  Logger.info('Starting RPC services generation...');

  let files: string[] = [];
  try {
    files = includes.reduce<string[]>((acc, include) => {
      const matchedFiles = glob.sync(include, { ignore: excludes });
      return [...acc, ...matchedFiles];
    }, []);

    if (!files.length) {
      Logger.warn('No files found with provided includes/excludes.');
      return;
    }
    Logger.info(`Files Scanned: ${files.length}`);
    Logger.debug('Matched files:', files);
  } catch (error) {
    Logger.error('Error scanning files:', error);
    return;
  }

  let classes: { name: string; path: string; }[] = [];
  try {
    const project = new Project({
      tsConfigFilePath: path.join(process.cwd(), "tsconfig.json"),
    });
    project.addSourceFilesAtPaths(files);

    classes = project.getSourceFiles().reduce<{ name: string; path: string; }[]>((acc, sourceFile) => {
      const foundClasses = sourceFile.getClasses().map(c => ({
        name: c.getName()!,
        path: sourceFile.getFilePath()
      }));
      return [...acc, ...foundClasses]
    }, []);

    if (!classes.length) {
      Logger.warn('No classes found in provided files.');
      return;
    }
    Logger.info(`Classes detected: ${classes.length}`);
    Logger.debug('Detected classes:', classes);
  } catch (error) {
    Logger.error('Error detecting classes:', error);
    return;
  }

  try {
    const project = new Project({
      tsConfigFilePath: path.join(process.cwd(), "tsconfig.json"),
    });

    const classImports = classes.map((c) => {
      const sourceFile = project.addSourceFileAtPath(c.path);
      const importPath = sourceFile.getRelativePathAsModuleSpecifierTo(
        path.join(process.cwd(), outputFile)
      );
      return `import { ${c.name} } from '${importPath}';`
    }).join('\n');

    Logger.debug('Generated imports:', classImports);

    const classProperties = classes.map(c =>
      `${c.name.replace(/Controller$/, 'Controller')}: ClassTypeProxy<${c.name}>;`
    ).join('\n');
    const classInits = classes.map(c =>
      `this.${c.name.replace(/Controller$/, 'Controller')} = this.rpcClient.createProxy(${c.name});`
    ).join('\n');

    const outputCode = `
    // This file is auto-generated by rpc-nats-alvamind
    import { RPCClient, ClassTypeProxy } from 'rpc-nats-alvamind';
    ${classImports}

    export class RPCServices {
        ${classProperties}
      constructor(private rpcClient: RPCClient) {
        ${classInits}
      }
    }
    `;

    await fs.writeFile(outputFile, outputCode, 'utf-8');
    Logger.info(`Generated ${outputFile} with ${classes.length} services.`);
    Logger.debug('Generated code:', outputCode);
  } catch (error) {
    Logger.error('Error writing the output file:', error);
    return;
  }

  const endTime = Date.now();
  const duration = (endTime - startTime) / 1000;
  Logger.info(`Completed in ${duration.toFixed(2)} seconds.`);
}

async function generateRpcServicesWithWatch(includes: string[], excludes: string[], outputFile: string) {
  let initialGenerationDone = false;
  const project = new Project({
    tsConfigFilePath: path.join(process.cwd(), "tsconfig.json"),
  });

  const generateAndLog = async () => {
    await generateRpcServices(includes, excludes, outputFile);
    if (!initialGenerationDone) {
      initialGenerationDone = true;
      Logger.info('Initial generation done. Watching for changes...');
    } else {
      Logger.info('Changes detected, Regenerated rpc-services.ts');
    }
  };

  const debouncedGenerate = debounce(generateAndLog, 300);

  const watcher = chokidar.watch(includes, {
    ignored: excludes,
    ignoreInitial: true
  });

  watcher.on('add', (filePath) => {
    Logger.debug(`File added: ${filePath}`);
    project.addSourceFileAtPath(filePath);
    debouncedGenerate();
  });

  watcher.on('change', (filePath) => {
    Logger.debug(`File changed: ${filePath}`);
    project.addSourceFileAtPath(filePath);
    debouncedGenerate();
  });

  watcher.on('unlink', (filePath) => {
    Logger.debug(`File removed: ${filePath}`);
    const sourceFile = project.getSourceFile(filePath);
    if (sourceFile) {
      project.removeSourceFile(sourceFile)
    }
    debouncedGenerate();
  });

  generateAndLog();
}

if (argv._.includes('generate')) {
  if (argv.watch) {
    generateRpcServicesWithWatch(argv.includes as string[], argv.excludes as string[], argv.output as string);
  } else {
    generateRpcServices(argv.includes as string[], argv.excludes as string[], argv.output as string);
  }
}
